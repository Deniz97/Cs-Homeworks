# Generated from mygram.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\36")
        buf.write("\u00c7\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\3\2\3\2\3\2\6\2+\n\2\r\2\16\2,\3\3\3\3\3\3\3\3\3")
        buf.write("\3\5\3\64\n\3\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5")
        buf.write("\3\6\3\6\5\6B\n\6\3\6\3\6\3\6\5\6G\n\6\7\6I\n\6\f\6\16")
        buf.write("\6L\13\6\3\6\5\6O\n\6\3\7\3\7\3\7\3\7\3\b\3\b\3\b\7\b")
        buf.write("X\n\b\f\b\16\b[\13\b\3\b\5\b^\n\b\3\t\3\t\3\t\6\tc\n\t")
        buf.write("\r\t\16\td\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3")
        buf.write("\13\7\13q\n\13\f\13\16\13t\13\13\3\13\3\13\3\13\3\f\3")
        buf.write("\f\3\f\5\f|\n\f\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16")
        buf.write("\5\16\u0087\n\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5")
        buf.write("\17\u0090\n\17\3\17\3\17\3\17\7\17\u0095\n\17\f\17\16")
        buf.write("\17\u0098\13\17\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\21\3\21\3\21\3\21\7\21\u00a7\n\21\f\21\16\21\u00aa")
        buf.write("\13\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3")
        buf.write("\22\3\22\3\22\7\22\u00b8\n\22\f\22\16\22\u00bb\13\22\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23\u00c5\n\23")
        buf.write("\3\23\2\5\34 \"\24\2\4\6\b\n\f\16\20\22\24\26\30\32\34")
        buf.write("\36 \"$\2\2\2\u00ce\2*\3\2\2\2\4\63\3\2\2\2\6\65\3\2\2")
        buf.write("\2\b;\3\2\2\2\nN\3\2\2\2\fP\3\2\2\2\16]\3\2\2\2\20b\3")
        buf.write("\2\2\2\22f\3\2\2\2\24i\3\2\2\2\26{\3\2\2\2\30}\3\2\2\2")
        buf.write("\32\u0086\3\2\2\2\34\u008f\3\2\2\2\36\u0099\3\2\2\2 \u009d")
        buf.write("\3\2\2\2\"\u00ab\3\2\2\2$\u00c4\3\2\2\2&\'\5\4\3\2\'(")
        buf.write("\7\3\2\2(+\3\2\2\2)+\5\6\4\2*&\3\2\2\2*)\3\2\2\2+,\3\2")
        buf.write("\2\2,*\3\2\2\2,-\3\2\2\2-\3\3\2\2\2.\64\5\36\20\2/\64")
        buf.write("\5\24\13\2\60\64\5\30\r\2\61\64\5\22\n\2\62\64\5\32\16")
        buf.write("\2\63.\3\2\2\2\63/\3\2\2\2\63\60\3\2\2\2\63\61\3\2\2\2")
        buf.write("\63\62\3\2\2\2\64\5\3\2\2\2\65\66\7\4\2\2\66\67\7\35\2")
        buf.write("\2\678\5\b\5\289\5\20\t\29:\7\5\2\2:\7\3\2\2\2;<\7\6\2")
        buf.write("\2<=\5\n\6\2=>\7\7\2\2>\t\3\2\2\2?B\7\35\2\2@B\5\36\20")
        buf.write("\2A?\3\2\2\2A@\3\2\2\2BJ\3\2\2\2CF\7\b\2\2DG\7\35\2\2")
        buf.write("EG\5\36\20\2FD\3\2\2\2FE\3\2\2\2GI\3\2\2\2HC\3\2\2\2I")
        buf.write("L\3\2\2\2JH\3\2\2\2JK\3\2\2\2KO\3\2\2\2LJ\3\2\2\2MO\3")
        buf.write("\2\2\2NA\3\2\2\2NM\3\2\2\2O\13\3\2\2\2PQ\7\6\2\2QR\5\16")
        buf.write("\b\2RS\7\7\2\2S\r\3\2\2\2TY\5 \21\2UV\7\b\2\2VX\5 \21")
        buf.write("\2WU\3\2\2\2X[\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z^\3\2\2\2[")
        buf.write("Y\3\2\2\2\\^\3\2\2\2]T\3\2\2\2]\\\3\2\2\2^\17\3\2\2\2")
        buf.write("_`\5\4\3\2`a\7\3\2\2ac\3\2\2\2b_\3\2\2\2cd\3\2\2\2db\3")
        buf.write("\2\2\2de\3\2\2\2e\21\3\2\2\2fg\7\t\2\2gh\5 \21\2h\23\3")
        buf.write("\2\2\2ij\7\n\2\2jk\5\34\17\2kr\5\20\t\2lm\7\13\2\2mn\5")
        buf.write("\34\17\2no\5\20\t\2oq\3\2\2\2pl\3\2\2\2qt\3\2\2\2rp\3")
        buf.write("\2\2\2rs\3\2\2\2su\3\2\2\2tr\3\2\2\2uv\5\26\f\2vw\7\f")
        buf.write("\2\2w\25\3\2\2\2xy\7\r\2\2y|\5\20\t\2z|\3\2\2\2{x\3\2")
        buf.write("\2\2{z\3\2\2\2|\27\3\2\2\2}~\7\16\2\2~\177\5\34\17\2\177")
        buf.write("\u0080\5\20\t\2\u0080\u0081\7\17\2\2\u0081\31\3\2\2\2")
        buf.write("\u0082\u0083\7\20\2\2\u0083\u0087\7\35\2\2\u0084\u0085")
        buf.write("\7\21\2\2\u0085\u0087\5 \21\2\u0086\u0082\3\2\2\2\u0086")
        buf.write("\u0084\3\2\2\2\u0087\33\3\2\2\2\u0088\u0089\b\17\1\2\u0089")
        buf.write("\u008a\5 \21\2\u008a\u008b\7\31\2\2\u008b\u008c\5 \21")
        buf.write("\2\u008c\u0090\3\2\2\2\u008d\u008e\7\33\2\2\u008e\u0090")
        buf.write("\5\34\17\3\u008f\u0088\3\2\2\2\u008f\u008d\3\2\2\2\u0090")
        buf.write("\u0096\3\2\2\2\u0091\u0092\f\4\2\2\u0092\u0093\7\32\2")
        buf.write("\2\u0093\u0095\5\34\17\5\u0094\u0091\3\2\2\2\u0095\u0098")
        buf.write("\3\2\2\2\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2\u0097")
        buf.write("\35\3\2\2\2\u0098\u0096\3\2\2\2\u0099\u009a\7\35\2\2\u009a")
        buf.write("\u009b\7\22\2\2\u009b\u009c\5 \21\2\u009c\37\3\2\2\2\u009d")
        buf.write("\u009e\b\21\1\2\u009e\u009f\5\"\22\2\u009f\u00a8\3\2\2")
        buf.write("\2\u00a0\u00a1\f\5\2\2\u00a1\u00a2\7\23\2\2\u00a2\u00a7")
        buf.write("\5\"\22\2\u00a3\u00a4\f\4\2\2\u00a4\u00a5\7\24\2\2\u00a5")
        buf.write("\u00a7\5\"\22\2\u00a6\u00a0\3\2\2\2\u00a6\u00a3\3\2\2")
        buf.write("\2\u00a7\u00aa\3\2\2\2\u00a8\u00a6\3\2\2\2\u00a8\u00a9")
        buf.write("\3\2\2\2\u00a9!\3\2\2\2\u00aa\u00a8\3\2\2\2\u00ab\u00ac")
        buf.write("\b\22\1\2\u00ac\u00ad\5$\23\2\u00ad\u00b9\3\2\2\2\u00ae")
        buf.write("\u00af\f\6\2\2\u00af\u00b0\7\25\2\2\u00b0\u00b8\5$\23")
        buf.write("\2\u00b1\u00b2\f\5\2\2\u00b2\u00b3\7\26\2\2\u00b3\u00b8")
        buf.write("\5$\23\2\u00b4\u00b5\f\4\2\2\u00b5\u00b6\7\27\2\2\u00b6")
        buf.write("\u00b8\5$\23\2\u00b7\u00ae\3\2\2\2\u00b7\u00b1\3\2\2\2")
        buf.write("\u00b7\u00b4\3\2\2\2\u00b8\u00bb\3\2\2\2\u00b9\u00b7\3")
        buf.write("\2\2\2\u00b9\u00ba\3\2\2\2\u00ba#\3\2\2\2\u00bb\u00b9")
        buf.write("\3\2\2\2\u00bc\u00c5\7\35\2\2\u00bd\u00c5\7\30\2\2\u00be")
        buf.write("\u00bf\7\6\2\2\u00bf\u00c0\5 \21\2\u00c0\u00c1\7\7\2\2")
        buf.write("\u00c1\u00c5\3\2\2\2\u00c2\u00c3\7\35\2\2\u00c3\u00c5")
        buf.write("\5\f\7\2\u00c4\u00bc\3\2\2\2\u00c4\u00bd\3\2\2\2\u00c4")
        buf.write("\u00be\3\2\2\2\u00c4\u00c2\3\2\2\2\u00c5%\3\2\2\2\26*")
        buf.write(",\63AFJNY]dr{\u0086\u008f\u0096\u00a6\u00a8\u00b7\u00b9")
        buf.write("\u00c4")
        return buf.getvalue()


class mygramParser ( Parser ):

    grammarFileName = "mygram.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'fun'", "'endf'", "'('", "')'", 
                     "','", "'return'", "'if'", "'else if'", "'endi'", "'else'", 
                     "'while'", "'endw'", "'input'", "'output'", "'='", 
                     "'-'", "'+'", "'*'", "'/'", "'%'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'!'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "NUM", "Bop", "Lop", "Uop", 
                      "WS", "ID", "COMMENT" ]

    RULE_prog = 0
    RULE_stmt = 1
    RULE_defin = 2
    RULE_plist = 3
    RULE_idargs = 4
    RULE_clist = 5
    RULE_args = 6
    RULE_stmts = 7
    RULE_ret = 8
    RULE_iff = 9
    RULE_elsee = 10
    RULE_wh = 11
    RULE_io = 12
    RULE_cond = 13
    RULE_ass = 14
    RULE_e = 15
    RULE_t = 16
    RULE_f = 17

    ruleNames =  [ "prog", "stmt", "defin", "plist", "idargs", "clist", 
                   "args", "stmts", "ret", "iff", "elsee", "wh", "io", "cond", 
                   "ass", "e", "t", "f" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    NUM=22
    Bop=23
    Lop=24
    Uop=25
    WS=26
    ID=27
    COMMENT=28

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.StmtContext)
            else:
                return self.getTypedRuleContext(mygramParser.StmtContext,i)


        def defin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.DefinContext)
            else:
                return self.getTypedRuleContext(mygramParser.DefinContext,i)


        def getRuleIndex(self):
            return mygramParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = mygramParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 40
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [mygramParser.T__6, mygramParser.T__7, mygramParser.T__11, mygramParser.T__13, mygramParser.T__14, mygramParser.ID]:
                    self.state = 36
                    self.stmt()
                    self.state = 37
                    self.match(mygramParser.T__0)
                    pass
                elif token in [mygramParser.T__1]:
                    self.state = 39
                    self.defin()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 42 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << mygramParser.T__1) | (1 << mygramParser.T__6) | (1 << mygramParser.T__7) | (1 << mygramParser.T__11) | (1 << mygramParser.T__13) | (1 << mygramParser.T__14) | (1 << mygramParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ass(self):
            return self.getTypedRuleContext(mygramParser.AssContext,0)


        def iff(self):
            return self.getTypedRuleContext(mygramParser.IffContext,0)


        def wh(self):
            return self.getTypedRuleContext(mygramParser.WhContext,0)


        def ret(self):
            return self.getTypedRuleContext(mygramParser.RetContext,0)


        def io(self):
            return self.getTypedRuleContext(mygramParser.IoContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmt" ):
                return visitor.visitStmt(self)
            else:
                return visitor.visitChildren(self)




    def stmt(self):

        localctx = mygramParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stmt)
        try:
            self.state = 49
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.ass()
                pass
            elif token in [mygramParser.T__7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.iff()
                pass
            elif token in [mygramParser.T__11]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.wh()
                pass
            elif token in [mygramParser.T__6]:
                self.enterOuterAlt(localctx, 4)
                self.state = 47
                self.ret()
                pass
            elif token in [mygramParser.T__13, mygramParser.T__14]:
                self.enterOuterAlt(localctx, 5)
                self.state = 48
                self.io()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefinContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(mygramParser.ID, 0)

        def plist(self):
            return self.getTypedRuleContext(mygramParser.PlistContext,0)


        def stmts(self):
            return self.getTypedRuleContext(mygramParser.StmtsContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_defin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefin" ):
                listener.enterDefin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefin" ):
                listener.exitDefin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefin" ):
                return visitor.visitDefin(self)
            else:
                return visitor.visitChildren(self)




    def defin(self):

        localctx = mygramParser.DefinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_defin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(mygramParser.T__1)
            self.state = 52
            self.match(mygramParser.ID)
            self.state = 53
            self.plist()
            self.state = 54
            self.stmts()
            self.state = 55
            self.match(mygramParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PlistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def idargs(self):
            return self.getTypedRuleContext(mygramParser.IdargsContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_plist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlist" ):
                listener.enterPlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlist" ):
                listener.exitPlist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlist" ):
                return visitor.visitPlist(self)
            else:
                return visitor.visitChildren(self)




    def plist(self):

        localctx = mygramParser.PlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_plist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self.match(mygramParser.T__3)
            self.state = 58
            self.idargs()
            self.state = 59
            self.match(mygramParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdargsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(mygramParser.ID)
            else:
                return self.getToken(mygramParser.ID, i)

        def ass(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.AssContext)
            else:
                return self.getTypedRuleContext(mygramParser.AssContext,i)


        def getRuleIndex(self):
            return mygramParser.RULE_idargs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdargs" ):
                listener.enterIdargs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdargs" ):
                listener.exitIdargs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdargs" ):
                return visitor.visitIdargs(self)
            else:
                return visitor.visitChildren(self)




    def idargs(self):

        localctx = mygramParser.IdargsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_idargs)
        self._la = 0 # Token type
        try:
            self.state = 76
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 63
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 61
                    self.match(mygramParser.ID)
                    pass

                elif la_ == 2:
                    self.state = 62
                    self.ass()
                    pass


                self.state = 72
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==mygramParser.T__5:
                    self.state = 65
                    self.match(mygramParser.T__5)
                    self.state = 68
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                    if la_ == 1:
                        self.state = 66
                        self.match(mygramParser.ID)
                        pass

                    elif la_ == 2:
                        self.state = 67
                        self.ass()
                        pass


                    self.state = 74
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [mygramParser.T__4]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def args(self):
            return self.getTypedRuleContext(mygramParser.ArgsContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_clist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClist" ):
                listener.enterClist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClist" ):
                listener.exitClist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClist" ):
                return visitor.visitClist(self)
            else:
                return visitor.visitChildren(self)




    def clist(self):

        localctx = mygramParser.ClistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_clist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(mygramParser.T__3)
            self.state = 79
            self.args()
            self.state = 80
            self.match(mygramParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def e(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.EContext)
            else:
                return self.getTypedRuleContext(mygramParser.EContext,i)


        def getRuleIndex(self):
            return mygramParser.RULE_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgs" ):
                listener.enterArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgs" ):
                listener.exitArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgs" ):
                return visitor.visitArgs(self)
            else:
                return visitor.visitChildren(self)




    def args(self):

        localctx = mygramParser.ArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_args)
        self._la = 0 # Token type
        try:
            self.state = 91
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.T__3, mygramParser.NUM, mygramParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                self.e(0)
                self.state = 87
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==mygramParser.T__5:
                    self.state = 83
                    self.match(mygramParser.T__5)
                    self.state = 84
                    self.e(0)
                    self.state = 89
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [mygramParser.T__4]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.StmtContext)
            else:
                return self.getTypedRuleContext(mygramParser.StmtContext,i)


        def getRuleIndex(self):
            return mygramParser.RULE_stmts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmts" ):
                listener.enterStmts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmts" ):
                listener.exitStmts(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmts" ):
                return visitor.visitStmts(self)
            else:
                return visitor.visitChildren(self)




    def stmts(self):

        localctx = mygramParser.StmtsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_stmts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 93
                self.stmt()
                self.state = 94
                self.match(mygramParser.T__0)
                self.state = 98 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << mygramParser.T__6) | (1 << mygramParser.T__7) | (1 << mygramParser.T__11) | (1 << mygramParser.T__13) | (1 << mygramParser.T__14) | (1 << mygramParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def e(self):
            return self.getTypedRuleContext(mygramParser.EContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_ret

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRet" ):
                listener.enterRet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRet" ):
                listener.exitRet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRet" ):
                return visitor.visitRet(self)
            else:
                return visitor.visitChildren(self)




    def ret(self):

        localctx = mygramParser.RetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ret)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(mygramParser.T__6)
            self.state = 101
            self.e(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IffContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.CondContext)
            else:
                return self.getTypedRuleContext(mygramParser.CondContext,i)


        def stmts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.StmtsContext)
            else:
                return self.getTypedRuleContext(mygramParser.StmtsContext,i)


        def elsee(self):
            return self.getTypedRuleContext(mygramParser.ElseeContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_iff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIff" ):
                listener.enterIff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIff" ):
                listener.exitIff(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIff" ):
                return visitor.visitIff(self)
            else:
                return visitor.visitChildren(self)




    def iff(self):

        localctx = mygramParser.IffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_iff)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(mygramParser.T__7)
            self.state = 104
            self.cond(0)
            self.state = 105
            self.stmts()
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==mygramParser.T__8:
                self.state = 106
                self.match(mygramParser.T__8)
                self.state = 107
                self.cond(0)
                self.state = 108
                self.stmts()
                self.state = 114
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 115
            self.elsee()
            self.state = 116
            self.match(mygramParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElseeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmts(self):
            return self.getTypedRuleContext(mygramParser.StmtsContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_elsee

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElsee" ):
                listener.enterElsee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElsee" ):
                listener.exitElsee(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElsee" ):
                return visitor.visitElsee(self)
            else:
                return visitor.visitChildren(self)




    def elsee(self):

        localctx = mygramParser.ElseeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_elsee)
        try:
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 118
                self.match(mygramParser.T__10)
                self.state = 119
                self.stmts()
                pass
            elif token in [mygramParser.T__9]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond(self):
            return self.getTypedRuleContext(mygramParser.CondContext,0)


        def stmts(self):
            return self.getTypedRuleContext(mygramParser.StmtsContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_wh

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWh" ):
                listener.enterWh(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWh" ):
                listener.exitWh(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWh" ):
                return visitor.visitWh(self)
            else:
                return visitor.visitChildren(self)




    def wh(self):

        localctx = mygramParser.WhContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_wh)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(mygramParser.T__11)
            self.state = 124
            self.cond(0)
            self.state = 125
            self.stmts()
            self.state = 126
            self.match(mygramParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(mygramParser.ID, 0)

        def e(self):
            return self.getTypedRuleContext(mygramParser.EContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_io

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIo" ):
                listener.enterIo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIo" ):
                listener.exitIo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIo" ):
                return visitor.visitIo(self)
            else:
                return visitor.visitChildren(self)




    def io(self):

        localctx = mygramParser.IoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_io)
        try:
            self.state = 132
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.T__13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                self.match(mygramParser.T__13)
                self.state = 129
                self.match(mygramParser.ID)
                pass
            elif token in [mygramParser.T__14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 130
                self.match(mygramParser.T__14)
                self.state = 131
                self.e(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def e(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.EContext)
            else:
                return self.getTypedRuleContext(mygramParser.EContext,i)


        def Bop(self):
            return self.getToken(mygramParser.Bop, 0)

        def Uop(self):
            return self.getToken(mygramParser.Uop, 0)

        def cond(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mygramParser.CondContext)
            else:
                return self.getTypedRuleContext(mygramParser.CondContext,i)


        def Lop(self):
            return self.getToken(mygramParser.Lop, 0)

        def getRuleIndex(self):
            return mygramParser.RULE_cond

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond" ):
                listener.enterCond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond" ):
                listener.exitCond(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond" ):
                return visitor.visitCond(self)
            else:
                return visitor.visitChildren(self)



    def cond(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = mygramParser.CondContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 26
        self.enterRecursionRule(localctx, 26, self.RULE_cond, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mygramParser.T__3, mygramParser.NUM, mygramParser.ID]:
                self.state = 135
                self.e(0)
                self.state = 136
                self.match(mygramParser.Bop)
                self.state = 137
                self.e(0)
                pass
            elif token in [mygramParser.Uop]:
                self.state = 139
                self.match(mygramParser.Uop)
                self.state = 140
                self.cond(1)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 148
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = mygramParser.CondContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_cond)
                    self.state = 143
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 144
                    self.match(mygramParser.Lop)
                    self.state = 145
                    self.cond(3) 
                self.state = 150
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class AssContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(mygramParser.ID, 0)

        def e(self):
            return self.getTypedRuleContext(mygramParser.EContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_ass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAss" ):
                listener.enterAss(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAss" ):
                listener.exitAss(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAss" ):
                return visitor.visitAss(self)
            else:
                return visitor.visitChildren(self)




    def ass(self):

        localctx = mygramParser.AssContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_ass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(mygramParser.ID)
            self.state = 152
            self.match(mygramParser.T__15)
            self.state = 153
            self.e(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def t(self):
            return self.getTypedRuleContext(mygramParser.TContext,0)


        def e(self):
            return self.getTypedRuleContext(mygramParser.EContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_e

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE" ):
                listener.enterE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE" ):
                listener.exitE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitE" ):
                return visitor.visitE(self)
            else:
                return visitor.visitChildren(self)



    def e(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = mygramParser.EContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_e, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            self.t(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 166
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 164
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                    if la_ == 1:
                        localctx = mygramParser.EContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_e)
                        self.state = 158
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 159
                        self.match(mygramParser.T__16)
                        self.state = 160
                        self.t(0)
                        pass

                    elif la_ == 2:
                        localctx = mygramParser.EContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_e)
                        self.state = 161
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 162
                        self.match(mygramParser.T__17)
                        self.state = 163
                        self.t(0)
                        pass

             
                self.state = 168
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class TContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def f(self):
            return self.getTypedRuleContext(mygramParser.FContext,0)


        def t(self):
            return self.getTypedRuleContext(mygramParser.TContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_t

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterT" ):
                listener.enterT(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitT" ):
                listener.exitT(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitT" ):
                return visitor.visitT(self)
            else:
                return visitor.visitChildren(self)



    def t(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = mygramParser.TContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_t, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.f()
            self._ctx.stop = self._input.LT(-1)
            self.state = 183
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 181
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                    if la_ == 1:
                        localctx = mygramParser.TContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_t)
                        self.state = 172
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 173
                        self.match(mygramParser.T__18)
                        self.state = 174
                        self.f()
                        pass

                    elif la_ == 2:
                        localctx = mygramParser.TContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_t)
                        self.state = 175
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 176
                        self.match(mygramParser.T__19)
                        self.state = 177
                        self.f()
                        pass

                    elif la_ == 3:
                        localctx = mygramParser.TContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_t)
                        self.state = 178
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 179
                        self.match(mygramParser.T__20)
                        self.state = 180
                        self.f()
                        pass

             
                self.state = 185
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class FContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(mygramParser.ID, 0)

        def NUM(self):
            return self.getToken(mygramParser.NUM, 0)

        def e(self):
            return self.getTypedRuleContext(mygramParser.EContext,0)


        def clist(self):
            return self.getTypedRuleContext(mygramParser.ClistContext,0)


        def getRuleIndex(self):
            return mygramParser.RULE_f

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterF" ):
                listener.enterF(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitF" ):
                listener.exitF(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitF" ):
                return visitor.visitF(self)
            else:
                return visitor.visitChildren(self)




    def f(self):

        localctx = mygramParser.FContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_f)
        try:
            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.match(mygramParser.ID)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                self.match(mygramParser.NUM)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 188
                self.match(mygramParser.T__3)
                self.state = 189
                self.e(0)
                self.state = 190
                self.match(mygramParser.T__4)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 192
                self.match(mygramParser.ID)
                self.state = 193
                self.clist()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[13] = self.cond_sempred
        self._predicates[15] = self.e_sempred
        self._predicates[16] = self.t_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def cond_sempred(self, localctx:CondContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def e_sempred(self, localctx:EContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def t_sempred(self, localctx:TContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         




